@Service
public class DataProcessingService {

    private final KafkaTemplate<String, String> kafkaTemplate;
    private final YourDataRepository dataRepository;
    private final ExecutorService executorService = Executors.newFixedThreadPool(5);

    @Autowired
    public DataProcessingService(KafkaTemplate<String, String> kafkaTemplate, YourDataRepository dataRepository) {
        this.kafkaTemplate = kafkaTemplate;
        this.dataRepository = dataRepository;
    }

    public void processAndSendData(List<YourDataModel> dataList) {
        List<Future<Void>> futures = new ArrayList<>();

        for (int i = 0; i < 5; i++) {
            int start = i * (dataList.size() / 5);
            int end = (i == 4) ? dataList.size() : (i + 1) * (dataList.size() / 5);

            List<YourDataModel> partition = dataList.subList(start, end);

            Future<Void> future = executorService.submit(() -> {
                sendToKafka(partition);
                return null;
            });

            futures.add(future);
        }

        // Wait for all threads to complete
        for (Future<Void> future : futures) {
            try {
                future.get();
            } catch (InterruptedException | ExecutionException e) {
                e.printStackTrace();
            }
        }

        // Update the status in the database after all messages are sent
        updateStatusInDatabase(dataList);
    }

    @Transactional
    public void sendToKafka(List<YourDataModel> dataList) {
        kafkaTemplate.executeInTransaction(operations -> {
            List<ListenableFuture<SendResult<String, String>>> futures = new ArrayList<>();
            for (YourDataModel data : dataList) {
                ListenableFuture<SendResult<String, String>> future = operations.send("your_topic", data.getKey(), data.getValue());
                futures.add(future);
            }

            for (ListenableFuture<SendResult<String, String>> future : futures) {
                future.addCallback(new ListenableFutureCallback<SendResult<String, String>>() {
                    @Override
                    public void onSuccess(SendResult<String, String> result) {
                        System.out.println("Message sent to Kafka with offset: " + result.getRecordMetadata().offset());
                    }

                    @Override
                    public void onFailure(Throwable ex) {
                        ex.printStackTrace();
                    }
                });
            }

            // Optionally, you can block and wait for all futures to complete if you need to ensure all messages are sent
            futures.forEach(f -> {
                try {
                    f.get(); // Block and wait for future to complete
                } catch (InterruptedException | ExecutionException e) {
                    e.printStackTrace();
                }
            });

            return null;
        });
    }

    @Transactional
    public void updateStatusInDatabase(List<YourDataModel> dataList) {
        dataList.forEach(data -> data.setStatus("SENT"));
        dataRepository.saveAll(dataList);
    }
}
